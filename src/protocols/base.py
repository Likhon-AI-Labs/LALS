"""
Base Protocol Handler
=====================
Abstract base class defining the interface for protocol handlers.
Both OpenAI and Anthropic handlers inherit from this class.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, AsyncIterator
from pydantic import BaseModel


class ProtocolMessage(BaseModel):
    """Generic message format for protocol handlers."""
    role: str
    content: str


class ProtocolRequest(BaseModel):
    """Generic request format for protocol handlers."""
    model: str
    max_tokens: Optional[int] = None
    temperature: Optional[float] = None
    top_p: Optional[float] = None
    top_k: Optional[float] = None
    stream: bool = False
    stop: Optional[List[str]] = None
    messages: List[ProtocolMessage] = []
    system: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None


class ProtocolResponse(BaseModel):
    """Generic response format for protocol handlers."""
    id: str
    model: str
    content: str
    stop_reason: str
    usage: Dict[str, int]


class StreamingChunk(BaseModel):
    """Generic streaming chunk format."""
    chunk_type: str
    index: Optional[int] = None
    content: Optional[str] = None
    stop_reason: Optional[str] = None
    usage: Optional[Dict[str, int]] = None


class BaseProtocolHandler(ABC):
    """
    Abstract base class for API protocol handlers.
    
    All protocol handlers (OpenAI, Anthropic) must implement these methods.
    """
    
    def __init__(self, model_engine):
        """
        Initialize the handler with a model engine.
        
        Args:
            model_engine: The LLM model engine instance
        """
        self.model = model_engine
    
    @property
    @abstractmethod
    def protocol_name(self) -> str:
        """Return the protocol name (e.g., 'openai', 'anthropic')."""
        pass
    
    @abstractmethod
    def validate_request(self, request: ProtocolRequest) -> bool:
        """
        Validate the incoming request.
        
        Args:
            request: The request object to validate
        
        Returns:
            True if valid, raises ValueError otherwise
        """
        pass
    
    @abstractmethod
    def format_prompt(self, request: ProtocolRequest) -> str:
        """
        Convert protocol-specific message format to model prompt.
        
        Args:
            request: The validated request object
        
        Returns:
            Formatted prompt string for the model
        """
        pass
    
    @abstractmethod
    def format_response(
        self,
        generated_text: str,
        request: ProtocolRequest,
        input_tokens: int,
        output_tokens: int,
        stop_reason: str = "stop"
    ) -> Dict[str, Any]:
        """
        Format the model's output into protocol-specific response.
        
        Args:
            generated_text: The text generated by the model
            request: The original request object
            input_tokens: Number of tokens in the prompt
            output_tokens: Number of tokens generated
            stop_reason: Reason for stopping generation
        
        Returns:
            Protocol-specific response dictionary
        """
        pass
    
    @abstractmethod
    async def format_streaming_response(
        self,
        tokens: AsyncIterator[str],
        request: ProtocolRequest,
        input_tokens: int
    ) -> AsyncIterator[str]:
        """
        Format streaming response in protocol-specific SSE format.
        
        Args:
            tokens: Async iterator of generated tokens
            request: The original request object
            input_tokens: Number of tokens in the prompt
        
        Yields:
            SSE-formatted strings for the protocol
        """
        pass
    
    def detect_protocol(self, request_body: Dict[str, Any]) -> Optional[str]:
        """
        Detect if a request body matches this protocol.
        
        Default implementation checks for protocol-specific fields.
        Can be overridden by subclasses.
        
        Args:
            request_body: Raw request body dictionary
        
        Returns:
            Protocol name if detected, None otherwise
        """
        # Check for Anthropic-specific fields
        anthropic_indicators = ["max_tokens_to_sample", "anthropic_version"]
        for indicator in anthropic_indicators:
            if indicator in request_body:
                return self.protocol_name
        
        # Check for Anthropic-style structure
        if "max_tokens" in request_body and "system" in request_body:
            return self.protocol_name
        
        return None


class ProtocolRouter:
    """
    Routes requests to appropriate protocol handlers.
    
    Maintains a registry of handlers and routes requests based on:
    1. Explicit protocol header
    2. Endpoint path
    3. Request body structure (auto-detection)
    """
    
    def __init__(self):
        self._handlers: Dict[str, BaseProtocolHandler] = {}
    
    def register_handler(self, protocol: str, handler: BaseProtocolHandler) -> None:
        """
        Register a protocol handler.
        
        Args:
            protocol: Protocol name (e.g., 'openai', 'anthropic')
            handler: Handler instance
        """
        self._handlers[protocol] = handler
        logger = logging.getLogger(__name__)
        logger.info(f"Registered handler for protocol: {protocol}")
    
    def get_handler(self, protocol: str) -> Optional[BaseProtocolHandler]:
        """
        Get a handler by protocol name.
        
        Args:
            protocol: Protocol name
        
        Returns:
            Handler instance or None if not found
        """
        return self._handlers.get(protocol)
    
    def detect_protocol_from_body(self, request_body: Dict[str, Any]) -> str:
        """
        Auto-detect protocol from request body structure.
        
        Priority:
        1. Anthropic: has 'max_tokens' and 'system' fields
        2. OpenAI: has 'messages' array
        
        Args:
            request_body: Raw request body
        
        Returns:
            Detected protocol name
        """
        # Anthropic detection
        if "max_tokens" in request_body:
            if "system" in request_body or "messages" in request_body:
                return "anthropic"
        
        # Default to OpenAI for messages array
        if "messages" in request_body and isinstance(request_body["messages"], list):
            return "openai"
        
        # Default fallback
        return "openai"
    
    def detect_protocol_from_headers(self, headers: Dict[str, str]) -> Optional[str]:
        """
        Detect protocol from request headers.
        
        Args:
            headers: Request headers dictionary
        
        Returns:
            Protocol name if specified in header, None otherwise
        """
        provider = headers.get("x-lals-provider") or headers.get("x-provider")
        if provider:
            return provider.lower()
        return None
    
    def detect_protocol_from_path(self, path: str) -> Optional[str]:
        """
        Detect protocol from endpoint path.
        
        Args:
            path: Request path
        
        Returns:
            Protocol name if path is protocol-specific
        """
        if path == "/v1/messages" or path == "/v1/complete":
            return "anthropic"
        if path == "/v1/chat/completions":
            return "openai"
        return None
    
    def route_request(
        self,
        path: str,
        headers: Dict[str, str],
        body: Dict[str, Any]
    ) -> BaseProtocolHandler:
        """
        Route a request to the appropriate handler.
        
        Priority:
        1. Header override
        2. Path-based detection
        3. Body auto-detection
        
        Args:
            path: Request path
            headers: Request headers
            body: Request body
        
        Returns:
            Appropriate protocol handler
        
        Raises:
            ValueError: If no suitable handler found
        """
        # Try header override first
        protocol = self.detect_protocol_from_headers(headers)
        if protocol and protocol in self._handlers:
            return self._handlers[protocol]
        
        # Try path-based detection
        protocol = self.detect_protocol_from_path(path)
        if protocol and protocol in self._handlers:
            return self._handlers[protocol]
        
        # Try body auto-detection
        protocol = self.detect_protocol_from_body(body)
        if protocol in self._handlers:
            return self._handlers[protocol]
        
        # Try each handler's detection
        for handler in self._handlers.values():
            if handler.detect_protocol(body):
                return handler
        
        # Default to first available handler
        if self._handlers:
            return next(iter(self._handlers.values()))
        
        raise ValueError("No protocol handler available")
